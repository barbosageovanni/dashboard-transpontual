#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Rotas CTEs - Conhecimentos de Transporte Eletrônico
app/routes/ctes.py - VERSÃO LIMPA SEM DUPLICAÇÕES
"""

from datetime import datetime, date, timedelta
from typing import Optional, Dict, Any, Tuple
import traceback
import io
import pandas as pd
from io import BytesIO

from flask import (
    Blueprint, render_template, request, jsonify,
    make_response, current_app, send_file, flash, redirect, url_for
)
from flask_login import login_required, current_user
from sqlalchemy import and_, or_, func
from werkzeug.utils import secure_filename

# Imports locais
from app.models.cte import CTE
from app import db

# Decorator customizado para APIs
from functools import wraps

def api_login_required(f):
    """Decorator para endpoints de API que retorna JSON 401 ao invés de redirect"""
    @wraps(f)
    def decorated_function(*args, **kwargs):
        if not current_user.is_authenticated:
            return jsonify({"success": False, "message": "Não autenticado"}), 401
        return f(*args, **kwargs)
    return decorated_function

# Importações condicionais de serviços
try:
    from app.services.importacao_service import ImportacaoService
    IMPORTACAO_SERVICE_OK = True
except ImportError:
    IMPORTACAO_SERVICE_OK = False
    current_app.logger.warning("ImportacaoService não disponível") if current_app else None

try:
    from app.services.atualizacao_service import AtualizacaoService
    ATUALIZACAO_SERVICE_OK = True
except ImportError:
    ATUALIZACAO_SERVICE_OK = False
    current_app.logger.warning("AtualizacaoService não disponível") if current_app else None

# Blueprint
bp = Blueprint("ctes", __name__, url_prefix="/ctes")

# ==================== PÁGINAS (VIEWS) ====================

@bp.route("/")
@login_required
def index():
    """Página principal de CTEs"""
    return render_template("ctes/index.html")

@bp.route("/listar")
@login_required
def listar():
    """Página de listagem de CTEs"""
    return render_template("ctes/index.html")

@bp.route("/dashboard")
@login_required
def dashboard_ctes():
    """Dashboard específico de CTEs"""
    try:
        stats = CTE.estatisticas_rapidas()
        return render_template("ctes/dashboard.html", stats=stats)
    except Exception as e:
        current_app.logger.error(f"Erro no dashboard CTEs: {e}")
        flash("Erro ao carregar dashboard", "error")
        return redirect(url_for("ctes.index"))

# ==================== API PRINCIPAL - TESTE DE CONECTIVIDADE ====================

@bp.route('/api/test-conexao-simples')
@api_login_required
def api_test_conexao_simples():
    """Teste de conectividade mais básico possível"""
    try:
        # Teste direto no banco
        from sqlalchemy import text
        result = db.session.execute(text("SELECT COUNT(*) as total FROM dashboard_baker")).fetchone()
        total_registros = result[0] if result else 0
        
        # Teste do modelo
        total_modelo = CTE.query.count()
        
        # Pegar um exemplo
        exemplo = CTE.query.first()
        exemplo_dict = None
        if exemplo:
            try:
                exemplo_dict = exemplo.to_dict()
                exemplo_status = 'OK'
            except Exception as e:
                exemplo_status = f'ERRO: {str(e)}'
                exemplo_dict = None
        
        return jsonify({
            'success': True,
            'conexao_banco': 'OK',
            'total_sql_direto': total_registros,
            'total_modelo': total_modelo,
            'modelo_funcional': total_registros == total_modelo,
            'exemplo_serializacao': exemplo_status,
            'exemplo_dados': exemplo_dict,
            'timestamp': datetime.now().isoformat()
        })
        
    except Exception as e:
        return jsonify({
            'success': False,
            'erro': str(e),
            'tipo_erro': type(e).__name__,
            'timestamp': datetime.now().isoformat()
        }), 500

# ==================== API PRINCIPAL - LISTAGEM SIMPLIFICADA ====================

@bp.route('/api/listar-simples')
@api_login_required  
def api_listar_simples():
    """API de listagem simplificada e robusta"""
    try:
        current_app.logger.info("Iniciando listagem simplificada")
        
        # Parâmetros básicos
        page = int(request.args.get('page', 1))
        per_page = min(int(request.args.get('per_page', 50)), 100)
        search = (request.args.get('search') or '').strip()
        
        # Query básica
        query = CTE.query
        
        # Filtro simples
        if search:
            if search.isdigit():
                query = query.filter(CTE.numero_cte == int(search))
            else:
                pattern = f"%{search}%"
                query = query.filter(
                    CTE.destinatario_nome.ilike(pattern)
                )
        
        # Contar total
        total = query.count()
        current_app.logger.info(f"Total encontrado: {total}")
        
        if total == 0:
            return jsonify({
                'success': True,
                'data': [],
                'ctes': [],
                'total': 0,
                'message': 'Nenhum registro encontrado',
                'pagination': {
                    'total': 0,
                    'pages': 0, 
                    'current_page': 1,
                    'per_page': per_page,
                    'has_next': False,
                    'has_prev': False
                }
            })
        
        # Buscar dados com paginação
        offset = (page - 1) * per_page
        ctes = query.order_by(CTE.numero_cte.desc()).offset(offset).limit(per_page).all()
        
        current_app.logger.info(f"CTEs recuperados: {len(ctes)}")
        
        # Serializar com tratamento robusto
        items = []
        erros_serializacao = 0
        
        for cte in ctes:
            try:
                item_dict = cte.to_dict()
                items.append(item_dict)
            except Exception as e:
                current_app.logger.error(f"Erro ao serializar CTE {cte.numero_cte}: {e}")
                erros_serializacao += 1
                # Fallback ultra-seguro
                items.append({
                    'numero_cte': cte.numero_cte,
                    'destinatario_nome': str(cte.destinatario_nome or 'N/A'),
                    'veiculo_placa': str(cte.veiculo_placa or ''),
                    'valor_total': float(cte.valor_total or 0),
                    'data_emissao': cte.data_emissao.strftime('%Y-%m-%d') if cte.data_emissao else None,
                    'has_baixa': bool(cte.data_baixa),
                    'status_baixa': 'Com Baixa' if cte.data_baixa else 'Sem Baixa',
                    'processo_completo': False,
                    'status_processo': 'Fallback',
                    'erro_original': True
                })
        
        # Calcular paginação
        total_pages = (total + per_page - 1) // per_page
        has_next = page < total_pages
        has_prev = page > 1
        
        current_app.logger.info(f"Serialização concluída: {len(items)} items, {erros_serializacao} erros")
        
        # Resposta padronizada
        response = {
            'success': True,
            'data': items,
            'ctes': items,  # Compatibilidade com frontend
            'total': total,
            'items_returned': len(items),
            'erros_serializacao': erros_serializacao,
            'pagination': {
                'total': total,
                'pages': total_pages,
                'current_page': page,
                'per_page': per_page,
                'has_next': has_next,
                'has_prev': has_prev
            },
            'filters': {
                'search': search,
                'page': page,
                'per_page': per_page
            },
            'timestamp': datetime.now().isoformat()
        }
        
        return jsonify(response)
        
    except Exception as e:
        current_app.logger.exception("Erro crítico na listagem simplificada")
        return jsonify({
            'success': False,
            'error': str(e),
            'data': [],
            'ctes': [],
            'total': 0,
            'timestamp': datetime.now().isoformat()
        }), 500

# ==================== API PRINCIPAL - LISTAGEM COMPLETA ====================

@bp.route('/api/listar')
@api_login_required
def api_listar():
    """API principal para listagem de CTEs com filtros avançados"""
    try:
        # Parâmetros de entrada
        search = (request.args.get('search') or '').strip()
        status_baixa = (request.args.get('status_baixa') or '').strip()
        status_processo = (request.args.get('status_processo') or '').strip()
        data_inicio = (request.args.get('data_inicio') or '').strip()
        data_fim = (request.args.get('data_fim') or '').strip()
        page = int(request.args.get('page', 1))
        per_page = min(int(request.args.get('per_page', 50)), 200)

        current_app.logger.info(f"API Listagem - Filtros: search='{search}', status_baixa='{status_baixa}', "
                               f"status_processo='{status_processo}', período='{data_inicio}' a '{data_fim}', "
                               f"page={page}, per_page={per_page}")

        # Construção da query
        query = CTE.query

        # Filtro de busca textual
        if search:
            try:
                if search.isdigit():
                    numero_cte = int(search)
                    query = query.filter(CTE.numero_cte == numero_cte)
                else:
                    pattern = f"%{search}%"
                    query = query.filter(or_(
                        CTE.destinatario_nome.ilike(pattern),
                        CTE.numero_fatura.ilike(pattern),
                        CTE.veiculo_placa.ilike(pattern),
                        CTE.observacao.ilike(pattern),
                    ))
            except Exception as e:
                current_app.logger.warning(f"Erro no filtro de busca: {e}")

        # Filtro por status de baixa
        if status_baixa == 'com_baixa':
            query = query.filter(CTE.data_baixa.isnot(None))
        elif status_baixa == 'sem_baixa':
            query = query.filter(CTE.data_baixa.is_(None))

        # Filtro por período
        if data_inicio or data_fim:
            di = _parse_date_filter(data_inicio)
            df = _parse_date_filter(data_fim)
            if di:
                query = query.filter(CTE.data_emissao >= di)
            if df:
                query = query.filter(CTE.data_emissao <= df)

        # Execução e paginação
        total_registros = query.count()
        pagination = query.order_by(CTE.numero_cte.desc()).paginate(
            page=page, per_page=per_page, error_out=False
        )

        # Serialização dos dados
        items = []
        for cte in pagination.items:
            try:
                item_dict = cte.to_dict()
                items.append(item_dict)
            except Exception as e:
                current_app.logger.error(f"Erro ao serializar CTE {cte.numero_cte}: {e}")
                items.append(_cte_fallback_dict(cte))

        # Resposta
        response = {
            'success': True,
            'data': items,
            'ctes': items,
            'pagination': {
                'total': pagination.total,
                'pages': pagination.pages,
                'current_page': page,
                'per_page': per_page,
                'has_next': pagination.has_next,
                'has_prev': pagination.has_prev,
            },
            'filters': {
                'search': search,
                'status_baixa': status_baixa,
                'status_processo': status_processo,
                'data_inicio': data_inicio,
                'data_fim': data_fim,
            },
            'meta': {
                'total_found': total_registros,
                'items_returned': len(items),
                'timestamp': datetime.now().isoformat()
            }
        }

        return jsonify(response)

    except Exception as e:
        current_app.logger.exception("Erro crítico na API de listagem")
        return _error_response(str(e), "Erro interno do servidor", 500)

# ==================== APIS ESPECÍFICAS ====================

@bp.route("/api/buscar/<int:numero_cte>")
@api_login_required
def api_buscar_cte(numero_cte: int):
    """Buscar CTE específico por número"""
    try:
        cte = CTE.query.filter_by(numero_cte=numero_cte).first()
        if not cte:
            return _error_response(
                f"CTE {numero_cte} não encontrado", 
                "Registro não encontrado", 
                404
            )
            
        data = cte.to_dict(incluir_detalhes=True)
        return _success_response({"cte": data})
        
    except Exception as e:
        current_app.logger.exception(f"Erro ao buscar CTE {numero_cte}")
        return _error_response(str(e), "Erro interno", 500)

@bp.route("/api/criar", methods=["POST"])
@api_login_required
def api_criar_cte():
    """Criar novo CTE"""
    try:
        dados = request.get_json()
        if not dados:
            return _error_response("Dados não fornecidos", "Requisição inválida", 400)
        
        if not dados.get('numero_cte'):
            return _error_response("Número do CTE é obrigatório", "Dados inválidos", 400)

        sucesso, resultado = CTE.criar_cte(dados)
        
        if sucesso:
            return _success_response({
                "message": "CTE criado com sucesso",
                "cte": resultado.to_dict()
            })
        else:
            return _error_response(resultado, "Erro na criação", 400)
            
    except Exception as e:
        current_app.logger.exception("Erro ao criar CTE")
        return _error_response(str(e), "Erro interno", 500)

@bp.route("/api/atualizar/<int:numero_cte>", methods=["PUT"])
@api_login_required
def api_atualizar_cte(numero_cte: int):
    """Atualizar CTE existente"""
    try:
        cte = CTE.query.filter_by(numero_cte=numero_cte).first()
        if not cte:
            return _error_response(f"CTE {numero_cte} não encontrado", "Registro não encontrado", 404)
        
        dados = request.get_json()
        if not dados:
            return _error_response("Dados não fornecidos", "Requisição inválida", 400)
        
        sucesso, mensagem = cte.atualizar(dados)
        
        if sucesso:
            return _success_response({
                "message": mensagem,
                "cte": cte.to_dict()
            })
        else:
            return _error_response(mensagem, "Erro na atualização", 400)
            
    except Exception as e:
        current_app.logger.exception(f"Erro ao atualizar CTE {numero_cte}")
        return _error_response(str(e), "Erro interno", 500)

@bp.route("/api/excluir/<int:numero_cte>", methods=["DELETE"])
@api_login_required
def api_excluir_cte(numero_cte: int):
    """Excluir CTE"""
    try:
        cte = CTE.query.filter_by(numero_cte=numero_cte).first()
        if not cte:
            return _error_response(f"CTE {numero_cte} não encontrado", "Registro não encontrado", 404)
        
        sucesso, mensagem = cte.deletar()
        
        if sucesso:
            return _success_response({"message": mensagem})
        else:
            return _error_response(mensagem, "Erro na exclusão", 500)
            
    except Exception as e:
        current_app.logger.exception(f"Erro ao excluir CTE {numero_cte}")
        return _error_response(str(e), "Erro interno", 500)

# ==================== ESTATÍSTICAS E RELATÓRIOS ====================

@bp.route("/api/estatisticas")
@api_login_required
def api_estatisticas():
    """Obter estatísticas dos CTEs"""
    try:
        stats = CTE.estatisticas_rapidas()
        
        # CTEs criados hoje
        hoje = datetime.now().date()
        hoje_inicio = datetime.combine(hoje, datetime.min.time())
        ctes_hoje = CTE.query.filter(CTE.created_at >= hoje_inicio).count() if hasattr(CTE, 'created_at') else 0
        
        # CTEs vencidos
        data_limite = hoje - timedelta(days=60)
        ctes_vencidos = CTE.query.filter(
            and_(
                CTE.data_baixa.is_(None),
                CTE.data_emissao < data_limite
            )
        ).count()
        
        stats.update({
            'ctes_hoje': ctes_hoje,
            'ctes_vencidos': ctes_vencidos,
            'timestamp': datetime.now().isoformat()
        })
        
        return _success_response({"estatisticas": stats})
        
    except Exception as e:
        current_app.logger.exception("Erro ao obter estatísticas")
        return _error_response(str(e), "Erro interno", 500)

# ==================== DEBUG E DIAGNÓSTICO ====================

@bp.route('/api/debug')
@api_login_required
def api_debug():
    """API de debug geral"""
    try:
        total = CTE.query.count()
        
        exemplo = CTE.query.order_by(CTE.numero_cte.desc()).first()
        exemplo_dict = None
        
        if exemplo:
            try:
                exemplo_dict = exemplo.to_dict()
            except Exception as e:
                exemplo_dict = {'erro_serializacao': str(e)}
        
        debug_info = {
            'sistema': {
                'total_ctes': total,
                'tabela': CTE.__tablename__,
                'modelo_funcional': True,
                'servicos': {
                    'importacao': IMPORTACAO_SERVICE_OK,
                    'atualizacao': ATUALIZACAO_SERVICE_OK,
                }
            },
            'exemplo_cte': exemplo_dict,
            'timestamp': datetime.now().isoformat()
        }
        
        return _success_response(debug_info)
        
    except Exception as e:
        current_app.logger.exception("Erro no debug")
        return _error_response(str(e), "Erro interno", 500)

# ==================== FUNÇÕES AUXILIARES ====================

def _success_response(data: Dict[str, Any], message: str = "Sucesso") -> Tuple[Dict, int]:
    """Padroniza respostas de sucesso"""
    response = {
        'success': True,
        'message': message,
        'timestamp': datetime.now().isoformat(),
        **data
    }
    return jsonify(response), 200

def _error_response(error: str, message: str = "Erro", status: int = 400) -> Tuple[Dict, int]:
    """Padroniza respostas de erro"""
    response = {
        'success': False,
        'error': error,
        'message': message,
        'timestamp': datetime.now().isoformat()
    }
    return jsonify(response), status

def _parse_date_filter(date_str: str) -> Optional[date]:
    """Parse seguro de datas para filtros"""
    if not date_str:
        return None
    try:
        return datetime.strptime(date_str, "%Y-%m-%d").date()
    except ValueError:
        try:
            return datetime.strptime(date_str, "%d/%m/%Y").date()
        except ValueError:
            current_app.logger.warning(f"Data inválida ignorada: {date_str}")
            return None

def _cte_fallback_dict(cte) -> Dict[str, Any]:
    """Fallback seguro para serialização de CTE"""
    return {
        'numero_cte': getattr(cte, 'numero_cte', 0),
        'destinatario_nome': str(getattr(cte, 'destinatario_nome', '') or ''),
        'valor_total': float(getattr(cte, 'valor_total', 0) or 0),
        'data_emissao': cte.data_emissao.strftime('%Y-%m-%d') if getattr(cte, 'data_emissao', None) else None,
        'has_baixa': bool(getattr(cte, 'data_baixa', None)),
        'processo_completo': False,
        'status_processo': 'Erro na serialização',
        'status_baixa': 'Pendente' if not getattr(cte, 'data_baixa', None) else 'Pago',
        'veiculo_placa': str(getattr(cte, 'veiculo_placa', '') or ''),
        'observacao': str(getattr(cte, 'observacao', '') or ''),
        'erro': 'Fallback utilizado'
    }