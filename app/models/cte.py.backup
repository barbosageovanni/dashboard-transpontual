#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Modelo CTE - Conhecimento de Transporte Eletrônico
app/models/cte.py - VERSÃO LIMPA E CORRIGIDA
"""

from __future__ import annotations

from app import db
from sqlalchemy import text
from sqlalchemy.exc import IntegrityError
from datetime import datetime, date
from decimal import Decimal, InvalidOperation
from typing import Dict, List, Tuple, Optional, Union
import logging

class CTE(db.Model):
    """
    Modelo para CTEs (Conhecimentos de Transporte Eletrônico)
    Tabela: dashboard_baker
    """
    __tablename__ = 'dashboard_baker'

    # ==================== CAMPOS DA TABELA ====================
    
    # Chave primária
    id = db.Column(db.Integer, primary_key=True)
    numero_cte = db.Column(db.Integer, unique=True, nullable=False, index=True)

    # Dados principais
    destinatario_nome = db.Column(db.String(255))
    veiculo_placa = db.Column(db.String(20))
    valor_total = db.Column(db.Numeric(15, 2), nullable=False, default=0)

    # Datas do processo
    data_emissao = db.Column(db.Date)
    data_baixa = db.Column(db.Date)

    # Dados de faturamento e processo
    numero_fatura = db.Column(db.String(100))
    data_inclusao_fatura = db.Column(db.Date)
    data_envio_processo = db.Column(db.Date)
    primeiro_envio = db.Column(db.Date)
    data_rq_tmc = db.Column(db.Date)
    data_atesto = db.Column(db.Date)
    envio_final = db.Column(db.Date)

    # Metadados
    observacao = db.Column(db.Text)
    origem_dados = db.Column(db.String(50), default='Sistema')
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    updated_at = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

    def __repr__(self) -> str:
        return f'<CTE {self.numero_cte}: {self.destinatario_nome or "Sem nome"}>'

    # ==================== HELPERS DE PARSING ====================
    
    @staticmethod
    def _clean_text(v: Optional[Union[str, int, float]]) -> Optional[str]:
        """Limpa e normaliza texto"""
        if v is None:
            return None
        s = str(v).strip()
        return s if s and s.lower() not in ['', 'null', 'none', 'nan'] else None

    @staticmethod
    def _parse_date(v: Optional[Union[str, date]]) -> Optional[date]:
        """
        Parse de datas flexível
        Aceita: None, date, 'yyyy-mm-dd', 'dd/mm/yyyy', 'yyyy/mm/dd'
        """
        if v in (None, ""):
            return None
        if isinstance(v, date):
            return v
        
        s = str(v).strip()
        if not s or s.lower() in ['null', 'none', 'nan']:
            return None
        
        # Formatos suportados
        formatos = ["%Y-%m-%d", "%d/%m/%Y", "%Y/%m/%d", "%d-%m-%Y"]
        
        for fmt in formatos:
            try:
                return datetime.strptime(s, fmt).date()
            except ValueError:
                continue
        
        # Tentativa com ISO flexível
        try:
            return datetime.fromisoformat(s.replace("/", "-")).date()
        except Exception:
            logging.warning(f"Data não reconhecida: {s}")
            return None

    @staticmethod
    def _parse_money(v: Optional[Union[str, int, float, Decimal]]) -> Optional[Decimal]:
        """Parse de valores monetários flexível"""
        if v in (None, ""):
            return None
        if isinstance(v, Decimal):
            return v
        
        # Limpar formatação brasileira e internacional
        s = str(v).strip().replace("R$", "").replace("$", "")
        s = s.replace(" ", "").replace("\u00a0", "")  # Remove espaços
        
        # Se tem vírgula e ponto, assume formato brasileiro (1.234,56)
        if "," in s and "." in s:
            if s.rfind(",") > s.rfind("."):
                # Formato brasileiro: 1.234,56
                s = s.replace(".", "").replace(",", ".")
            # Senão mantém formato internacional: 1,234.56
            else:
                s = s.replace(",", "")
        # Se tem apenas vírgula, pode ser decimal brasileiro
        elif "," in s and s.count(",") == 1:
            # Se tem mais de 3 dígitos após vírgula, é separador de milhares
            if len(s.split(",")[-1]) > 3:
                s = s.replace(",", "")
            else:
                s = s.replace(",", ".")
        
        try:
            return Decimal(s)
        except (InvalidOperation, ValueError):
            logging.warning(f"Valor monetário não reconhecido: {v}")
            return None

    # ==================== PROPRIEDADES CALCULADAS ====================
    
    @property
    def has_baixa(self) -> bool:
        """Verifica se CTE possui baixa/pagamento"""
        return self.data_baixa is not None

    @property
    def processo_completo(self) -> bool:
        """Verifica se processo está completo (todas etapas preenchidas)"""
        etapas_obrigatorias = [
            self.data_emissao,
            self.primeiro_envio,
            self.data_atesto,
            self.envio_final
        ]
        return all(etapa is not None for etapa in etapas_obrigatorias)

    @property
    def status_processo(self) -> str:
        """Retorna status do processo baseado nas etapas concluídas"""
        if self.processo_completo:
            return 'Finalizado' if self.has_baixa else 'Completo'
        elif self.envio_final:
            return 'Envio Final'
        elif self.data_atesto:
            return 'Atestado'
        elif self.primeiro_envio:
            return 'Enviado'
        elif self.data_emissao:
            return 'Emitido'
        else:
            return 'Pendente'

    @property
    def status_baixa(self) -> str:
        """Status da baixa/pagamento"""
        if self.has_baixa:
            return 'Pago'
        elif self.data_emissao:
            dias_vencido = (datetime.now().date() - self.data_emissao).days
            if dias_vencido > 60:
                return 'Vencido'
            elif dias_vencido > 30:
                return 'A Vencer'
        return 'Pendente'

    @property
    def dias_em_processo(self) -> Optional[int]:
        """Dias desde a emissão"""
        if not self.data_emissao:
            return None
        return (datetime.now().date() - self.data_emissao).days

    # ==================== SERIALIZAÇÃO CORRIGIDA ====================
    
    def to_dict(self, incluir_detalhes=False):
        """Serialização robusta e corrigida"""
        try:
            def safe_date_format(date_obj, formato='%Y-%m-%d'):
                if not date_obj:
                    return None
                try:
                    if hasattr(date_obj, 'strftime'):
                        return date_obj.strftime(formato)
                    return str(date_obj)
                except:
                    return None

            def safe_numeric(value):
                if value is None:
                    return 0.0
                try:
                    return float(value)
                except:
                    return 0.0

            base_dict = {
                'numero_cte': int(self.numero_cte) if self.numero_cte else 0,
                'destinatario_nome': str(self.destinatario_nome or ''),
                'veiculo_placa': str(self.veiculo_placa or ''),
                'valor_total': safe_numeric(self.valor_total),
                'data_emissao': safe_date_format(self.data_emissao),
                'has_baixa': bool(self.data_baixa),
                'status_baixa': 'Com Baixa' if self.data_baixa else 'Sem Baixa'
            }

            try:
                processo_completo = bool(
                    self.data_emissao and 
                    self.primeiro_envio and 
                    self.data_atesto and 
                    self.envio_final
                )
                
                if processo_completo:
                    status_processo = 'Completo'
                elif self.data_atesto:
                    status_processo = 'Atestado'
                elif self.primeiro_envio:
                    status_processo = 'Em Andamento'
                else:
                    status_processo = 'Pendente'
                    
                base_dict.update({
                    'processo_completo': processo_completo,
                    'status_processo': status_processo
                })
            except:
                base_dict.update({
                    'processo_completo': False,
                    'status_processo': 'Erro'
                })

            if incluir_detalhes:
                base_dict.update({
                    'numero_fatura': str(self.numero_fatura or ''),
                    'data_baixa': safe_date_format(self.data_baixa),
                    'data_inclusao_fatura': safe_date_format(self.data_inclusao_fatura),
                    'data_envio_processo': safe_date_format(self.data_envio_processo),
                    'primeiro_envio': safe_date_format(self.primeiro_envio),
                    'data_rq_tmc': safe_date_format(self.data_rq_tmc),
                    'data_atesto': safe_date_format(self.data_atesto),
                    'envio_final': safe_date_format(self.envio_final),
                    'observacao': str(self.observacao or ''),
                    'origem_dados': str(self.origem_dados or 'Sistema')
                })

            return base_dict

        except Exception as e:
            return {
                'numero_cte': getattr(self, 'numero_cte', 0),
                'destinatario_nome': 'Erro na serialização',
                'valor_total': 0.0,
                'data_emissao': None,
                'has_baixa': False,
                'status_baixa': 'Erro',
                'processo_completo': False,
                'status_processo': 'Erro',
                'erro_serializacao': str(e)
            }

    # ==================== MÉTODOS CRUD ====================
    
    @classmethod
    def buscar_por_numero(cls, numero_cte: int) -> Optional["CTE"]:
        """Busca CTE por número"""
        try:
            return cls.query.filter_by(numero_cte=int(numero_cte)).first()
        except (ValueError, TypeError):
            return None

    @classmethod
    def criar_cte(cls, dados: Dict) -> Tuple[bool, Union[str, "CTE"]]:
        """
        Cria novo CTE
        
        Returns:
            Tuple[bool, Union[str, CTE]]: (sucesso, mensagem_erro_ou_cte)
        """
        try:
            if not dados.get('numero_cte'):
                return False, "Número do CTE é obrigatório"

            numero = int(dados['numero_cte'])
            
            # Verificar se já existe
            if cls.buscar_por_numero(numero):
                return False, f"CTE {numero} já existe no sistema"

            # Criar nova instância
            cte = cls()
            sucesso, mensagem = cte._aplicar_dados(dados)
            
            if not sucesso:
                return False, mensagem

            # Salvar no banco
            db.session.add(cte)
            db.session.commit()
            
            logging.info(f"CTE {numero} criado com sucesso")
            return True, cte
            
        except Exception as e:
            db.session.rollback()
            logging.error(f"Erro ao criar CTE: {e}")
            return False, f"Erro interno: {str(e)}"

    def atualizar(self, dados: Dict) -> Tuple[bool, str]:
        """
        Atualiza dados do CTE
        
        Returns:
            Tuple[bool, str]: (sucesso, mensagem)
        """
        try:
            sucesso, mensagem = self._aplicar_dados(dados)
            if not sucesso:
                return False, mensagem
                
            self.updated_at = datetime.utcnow()
            db.session.commit()
            
            logging.info(f"CTE {self.numero_cte} atualizado com sucesso")
            return True, "CTE atualizado com sucesso"
            
        except Exception as e:
            db.session.rollback()
            logging.error(f"Erro ao atualizar CTE {self.numero_cte}: {e}")
            return False, f"Erro ao atualizar: {str(e)}"

    def deletar(self) -> Tuple[bool, str]:
        """Remove CTE do banco"""
        try:
            numero = self.numero_cte
            db.session.delete(self)
            db.session.commit()
            
            logging.info(f"CTE {numero} removido com sucesso")
            return True, f"CTE {numero} removido com sucesso"
            
        except Exception as e:
            db.session.rollback()
            logging.error(f"Erro ao deletar CTE {self.numero_cte}: {e}")
            return False, f"Erro ao deletar: {str(e)}"

    # ==================== APLICAÇÃO DE DADOS ====================
    
    def _aplicar_dados(self, dados: Dict) -> Tuple[bool, str]:
        """
        Aplica dados no modelo com parsing tolerante
        Suporta nomes de campos em português e inglês
        """
        if not dados:
            return True, "Nenhum dado para aplicar"
        
        # Mapeamento de aliases para campos reais
        mapeamento_campos = {
            # Campos principais
            'numero_cte': 'numero_cte', 'Número CTE': 'numero_cte', 'num_cte': 'numero_cte',
            'destinatario_nome': 'destinatario_nome', 'Cliente': 'destinatario_nome', 'destinatario': 'destinatario_nome',
            'veiculo_placa': 'veiculo_placa', 'Placa Veículo': 'veiculo_placa', 'placa': 'veiculo_placa',
            'valor_total': 'valor_total', 'Valor Total': 'valor_total', 'valor': 'valor_total',
            
            # Datas
            'data_emissao': 'data_emissao', 'Data Emissão': 'data_emissao', 'emissao': 'data_emissao',
            'data_baixa': 'data_baixa', 'Data Baixa': 'data_baixa', 'baixa': 'data_baixa',
            'numero_fatura': 'numero_fatura', 'Número Fatura': 'numero_fatura', 'fatura': 'numero_fatura',
            
            # Processo
            'data_inclusao_fatura': 'data_inclusao_fatura', 'Data Inclusão Fatura': 'data_inclusao_fatura',
            'data_envio_processo': 'data_envio_processo', 'Data Envio Processo': 'data_envio_processo',
            'primeiro_envio': 'primeiro_envio', 'Primeiro Envio': 'primeiro_envio', '1º Envio': 'primeiro_envio',
            'data_rq_tmc': 'data_rq_tmc', 'Data RQ/TMC': 'data_rq_tmc', 'RQ/TMC': 'data_rq_tmc',
            'data_atesto': 'data_atesto', 'Data Atesto': 'data_atesto', 'atesto': 'data_atesto',
            'envio_final': 'envio_final', 'Envio Final': 'envio_final', 'final': 'envio_final',
            
            # Outros
            'observacao': 'observacao', 'Observação': 'observacao', 'obs': 'observacao',
        }

        # Normalizar dados
        dados_normalizados = {}
        for chave, valor in dados.items():
            campo_real = mapeamento_campos.get(chave, chave)
            dados_normalizados[campo_real] = valor

        # Aplicar cada campo
        try:
            # Número CTE (obrigatório para criação)
            if 'numero_cte' in dados_normalizados and dados_normalizados['numero_cte'] not in (None, ''):
                try:
                    self.numero_cte = int(str(dados_normalizados['numero_cte']).strip())
                except (ValueError, TypeError):
                    return False, f"Número do CTE inválido: {dados_normalizados['numero_cte']}"

            # Campos de texto
            if 'destinatario_nome' in dados_normalizados:
                self.destinatario_nome = self._clean_text(dados_normalizados['destinatario_nome'])

            if 'veiculo_placa' in dados_normalizados:
                self.veiculo_placa = self._clean_text(dados_normalizados['veiculo_placa'])
                
            if 'numero_fatura' in dados_normalizados:
                self.numero_fatura = self._clean_text(dados_normalizados['numero_fatura'])
                
            if 'observacao' in dados_normalizados:
                self.observacao = self._clean_text(dados_normalizados['observacao'])

            # Valor total
            if 'valor_total' in dados_normalizados:
                valor = self._parse_money(dados_normalizados['valor_total'])
                if valor is None and dados_normalizados['valor_total'] not in (None, ''):
                    return False, f"Valor total inválido: {dados_normalizados['valor_total']}"
                if valor is not None:
                    self.valor_total = valor

            # Datas do processo
            campos_data = [
                'data_emissao', 'data_baixa', 'data_inclusao_fatura', 'data_envio_processo',
                'primeiro_envio', 'data_rq_tmc', 'data_atesto', 'envio_final'
            ]
            
            for campo_data in campos_data:
                if campo_data in dados_normalizados:
                    data_parseada = self._parse_date(dados_normalizados[campo_data])
                    setattr(self, campo_data, data_parseada)

            return True, "Dados aplicados com sucesso"
            
        except Exception as e:
            logging.error(f"Erro ao aplicar dados: {e}")
            return False, f"Erro interno ao aplicar dados: {str(e)}"

    # ==================== MÉTODOS UTILITÁRIOS ====================
    
    @classmethod
    def obter_ctes_existentes_bulk(cls, numeros: List[int]) -> set:
        """
        Retorna conjunto de números de CTEs que já existem no banco
        Útil para importações em lote
        """
        try:
            if not numeros:
                return set()
            
            # Converter para int e remover inválidos
            numeros_validos = []
            for num in numeros:
                try:
                    numeros_validos.append(int(num))
                except (ValueError, TypeError):
                    continue
            
            if not numeros_validos:
                return set()
            
            # Query otimizada
            resultado = db.session.query(cls.numero_cte).filter(
                cls.numero_cte.in_(numeros_validos)
            ).all()
            
            return {r[0] for r in resultado}
            
        except Exception as e:
            logging.error(f"Erro em obter_ctes_existentes_bulk: {e}")
            return set()

    @classmethod
    def estatisticas_rapidas(cls) -> Dict:
        """Retorna estatísticas básicas dos CTEs"""
        try:
            from sqlalchemy import func
            
            total = cls.query.count()
            com_baixa = cls.query.filter(cls.data_baixa.isnot(None)).count()
            
            # Soma de valores
            valor_total = db.session.query(func.sum(cls.valor_total)).scalar() or 0
            valor_pago = db.session.query(func.sum(cls.valor_total)).filter(
                cls.data_baixa.isnot(None)
            ).scalar() or 0
            
            return {
                'total_ctes': total,
                'com_baixa': com_baixa,
                'sem_baixa': total - com_baixa,
                'valor_total': float(valor_total),
                'valor_pago': float(valor_pago),
                'valor_pendente': float(valor_total - valor_pago),
                'percentual_pago': round((valor_pago / valor_total * 100) if valor_total > 0 else 0, 2)
            }
            
        except Exception as e:
            logging.error(f"Erro ao calcular estatísticas: {e}")
            return {'erro': str(e)}

    def calcular_dias_processo(self) -> Dict[str, Optional[int]]:
        """Calcula variações de dias entre etapas do processo"""
        variacoes = {}
        
        try:
            # Mapeamento de variações
            calculos = [
                ('cte_inclusao_fatura', self.data_emissao, self.data_inclusao_fatura),
                ('cte_envio_processo', self.data_emissao, self.data_envio_processo),
                ('inclusao_envio_processo', self.data_inclusao_fatura, self.data_envio_processo),
                ('inclusao_primeiro_envio', self.data_inclusao_fatura, self.primeiro_envio),
                ('rq_tmc_primeiro_envio', self.data_rq_tmc, self.primeiro_envio),
                ('primeiro_envio_atesto', self.primeiro_envio, self.data_atesto),
                ('atesto_envio_final', self.data_atesto, self.envio_final),
            ]
            
            for nome, data_inicio, data_fim in calculos:
                if data_inicio and data_fim:
                    variacoes[nome] = (data_fim - data_inicio).days
                else:
                    variacoes[nome] = None
                    
        except Exception as e:
            logging.error(f"Erro ao calcular dias do processo CTE {self.numero_cte}: {e}")
            
        return variacoes